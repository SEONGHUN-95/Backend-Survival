# JPA 활용 전략

JPA가 어떻게 등장하게 되었는지, 어떤 점을 주의해서 사용해야 하는지, Best Practice는 어떤건지 알아보자.

# 기존 문제점 

Java는 객체지향 언어이다. 그래서 코드가 다 클래스와 메서드로 이루어져 있다. 
이 객체지향 언어로 영구 저장소의 데이터를 불러오고 저장하고 하는 과정은 다음과 같다. 

1. SQL문 작성

```

String query = "SELECT NAME, HEIGHT FROM MEMBER WHERE NAME = ?";

```

2. JDBC로 실행

```

ResultSet rs = stmt.executeQuery(query);

```

3. 객체 - DB 연관관계 매핑

```

String memberName = rs.getString("NAME");
String memberHeight = rs.getString("HEIGHT");

Member member = new Member();
member.setName(memberName);
member.setHeight(memberHeight);

```

데이터베이스에서 데이터를 CRUD하는 코드 하나 하나 다 위와 같은 과정을 거쳐야 한다.
이렇게 되면 코드가 DB에 강하게 의존하게 된다. 

또, 요구사항 변화로 데이터베이스에 테이블이 바뀐다고 치자. 그럼 함께 바꾸어야 하는건 뭘까?
위 과정을 한 번 더 실행해주어야 한다. 클래스의 필드 추가는 물론이고 JDBC 코드를 바꾸며, DAO를 수정해주어야 한다.
최초 코드 작성 후 이러한 변동 사항이 있을 때마다 모든 수정 사항에 대해 다 매핑해주어야 한다. 

# 하지만 JPA라면 어떨까?

JPA는 객체와 DB를 매핑해주는 인터페이스라고 하였다.
객체에 수정 사항을 적용하고 싶다면 객체를 수정하고, 객체를 다루는 메서드만 변경해주면 개발자가 영속성 게층에 직접 쿼리를 날릴 필요 없이 수정이 가능하다.

```

class Member{
    String id;
    String name;
    int height

    // 수정 필드
    int salary;
}

// 새로 추가된 필드 조건을 적용한 메서드를 사용하여 데이터 불러오기

jpa.findBySalarayGraterThanEqual(salary);

```

이외에도 객체지향의 상속 개념, 연관관계 등을 쉽게 설정하고 Java의 컬렉션에서 데이터를 다루듯 사용할 수 있어 편리하다.

# JPA 적용

## @Entity

DB 테이블에 매핑할 클래스는 @Entity 어노테이션을 달아서 사용한다. 하지만 주의사항이 있다. 

- 기본생성자 필요
- 저장 필드에 final 사용 불가
- final 클래스에 사용 불가

## 기본 키 매핑

기본 키를 직접 작성해주는 방법이 있고, 다른 조건을 입력하여 자동 증가시키거나 값을 생성하여 입력시켜주는 방식 등이 있다.
권장하는 방식은 기본 키는 대리 키(유일하지만 비즈니스에 의미 없는 키)를 사용함으로써 유일하고, null 값이 아니며, 변하지 않는 값을 기본 키로 사용하는 것이다. JPA에서 저장된 엔티티의 기본 키가 변경되면 예외가 발생하거나 정상 동작하지 않으므로 setter 생성 등을 주의해야한다.


# 연관관계 매핑

일반적으로 데이터는 서로 연관관계를 가질 수밖에 없다. DB에서는 그 방법을 잘 알고 있다. Foreign key를 통해 서로 연관관계를 맺어줄 수 있었다.
그렇다면 JPA, ORM을 사용했을 때 엔티티에서는 어떻게 연관관계를 맺을 수 있을까?
세 가지를 고려해야 한다.

1. 관계 방향
2. 다중성(Multiplicity)
3. 연관관계 주인

## 관계 방향

관계 방향이란 엔티티 간의 관계에서 서로 참조하는지, 한 쪽만 참조하는지를 의미한다. 
데이터베이스에서는 외래 키만으로도 서로 참조(양방향)가 가능하지만, 객체는 참조를 통해 다른 클래스의 데이터를 불러오기 때문에 단방향 매핑만이 가능하다.
따라서 두 엔티티가 서로의 값을 불러올 상황이라면 두 엔티티에 모두 참조를 설정해서 단방향 매핑관계를 두 번 설정해야한다.
단, 비즈니스 로직에서 상호 데이터간에 필요할 상황을 잘 고려해서 설계해야한다.

## 다중성

다중성이란 1:1, 1:N, M:N 등의 엔티티간의 상호 관계를 의미한다. 한 사람에게 하나의 아이템만 쥐어진다면 이는 1:1 관계이고, 하나의 그룹에 여러 사람이 속해 있다면 1:N의 관계가 될 것이며 여러 사람이 여러 게시물에 좋아요를 누를 수 있는 상황은 M:N의 관계가 될 것이다.
엔티티의 필드 위에 어노테이션으로 설정이 가능하다.

> M:N 관계는 피하자. M:N 관계도 설정이 가능하고 자동으로 매핑 필드들을 만들어주어 편해보이지만, 최초 설정 이후 필드를 추가하기 어렵다. 
 관계를 풀어 1:N, N:1 관계로 만들자.

## 연관관계 주인

연관관계의 주인은 양방향 관계에서 외래 키 관리자를 선택하는 것을 의미한다. 
1:N 관계에서는 항상 N측이 외래키를 관리하고, 1측의 필드에는 MappedBy()조건을 추가해주어야 한다. 연관관계의 주인이 아닌 쪽은 읽기만 가능하고 외래 키 변경은 제한된다. 
양방향 매핑에서 데이터를 저장할 때 연관관계 주인이 아닌 곳에 데이터를 추가한다면 주인인 쪽에 데이터에는 저장이 되지 않는다. 데이터 추가시 양쪽 엔티티에 모두 저장하여야 안전한 데이터 유지가 가능하다.

