# API(Application Programming Interface)
API란 컴퓨터(프로그램)에서 다른 컴퓨터(프로그램)로 데이터를 주고 받기 위한 방법을 의미한다. 예를 들어, 클라이언트가 서버의 특정 데이터를 불러오기 위해 요청을 처리하고 응답을 반환하는 코드를 웹 API라고 할 수 있다. 
웹 API를 호출할 때에는 메서드, 엔드포인트, 매개변수 등이 포함되는데 메서드는 어떠한 요청을 할 것인지, 엔드포인트는 요청하는 리소스의 위치가 어딘지, 매개변수는 리소스에 대한 상세한 내용을 담고 있다.
## 정보은닉(Information Hiding)과 캡슐화(Encapsulation)
### 정보은닉
정보은닉은 클래스 등 작성된 코드들을 숨겨 사용자로부터 접근을 제어하여 무결성을 보장하는 것을 의미한다. 접근제어자도 정보은닉의 도구로써 사용되고, 캡슐화도 정보은닉의 방법이라고 할 수 있겠다.
### 캡슐화
캡슐화는 객체의 데이터나 메서드를 구획화하고 일부 데이터의 접근을 제한하는 방법을 의미한다. 개발자가 의도하지 않은 방식으로 내부 상태를 직접 접근할 수 없게 하고 인터페이스를 통해서만 조작할 수 있게 함으로써 객체의 무결성도 보장할 수 있다.
또한, 인터페이스와 구현부를 나누어 구현부만 다른 것으로 바꾸어 사용함으로써 유연한 설계를 가능케하기도 한다.

정보 은닉은 객체 내부 데이터와 구현 내용을 숨기는 것에 초점을, 캡슐화는 정보 은닉과 같이 데이터의 무결성을 보장하면서도 데이터를 구획화함으로써 유연하고 객체지향적인 코드 구현에 초점을 맞춘다는 것에 차이가 있다.

## Architecture와 Architecture Style의 차이
아키텍처는 하드웨어와 소프트웨어 상의 구조를 의미하고 아키텍처 스타일은 소프트웨어 설계시 따르는 소프트웨어 설계 방식이라고 할 수 있다.

로이필딩은 2000년 박사논문인 “Architectural Styles and the Design of Network-based Software Architectures”에서 네트워크 기반의 소프트웨어 아키텍처에 대한 제안을 하였다. 논문의 5장에서는 REST라는 아키텍처 스타일을 제안한다.

## REST
REST(Representational State Transfer)는 www 등의 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 개념이다. 
7가지 제약조건을 통해 REST 아키텍처 스타일을 구축할 수 있다.
1. Starting With the Null Style
빈 제약 조건에서 시작해야 한다.
2. Client - Server
사용자 인터페이스와 서버 구성 요소를 분리하여 클라이언트의 이식성과 서버의 확장성을 향상시킨다. 
3. Stateless
클라이언트와 서버 모두 무상태성을 가져야 한다. 따라서, 모든 요청은 필요한 모든 정보를 담고 있어 서버의 확장성 향상이 가능케 한다.
4. Cache
응답에 대한 캐시가 가능한지 불가능한지 확인 가능하게 설계하여 성능을 향상시켜야 한다.
5. Uniform Interface
** REST 아키텍처 스타일은 다른 네트워크 기반과 달리 요소간 동일한 인터페이스에 중점을 둔다는 특징을 갖는다. ** 이러한 특징 때문에 시스템의 아키텍처가 단순화되고 웹에서의 "독립적인 진화"가 가능하게 하지만, 일관적인 스타일로 인해 다른 아키텍처에서는 효율성을 저하시키곤 한다.
5-1. Identification of resources
요청에서 자원을 식별할 수 있어야 한다.(리소스가 URI에서 식별되어야 한다.)
5-2. Manipulation of resources through representations
요청 안에 자원을 조작하는 명령어를 담고 있어야 한다. (요청 메서드 포함)
5-3. self-descriptive messages
각 메시지가 스스로를 어떻게 처리해야 하는지를 설명해야한다. 미디어타입에 대한 정보 만으로도 데이터가 무슨 작업을 위한 데이터인지 알 수 있어야 한다.
5-4. hypermedia as the engine of application(HATEOAS)
애플리케이션의 상태가 Hyperlink를 통해 전이되어야 한다. RESTful API를 구현한다고 하면, 클라이언트가 특정 리소스를 요청했을 때 서버는 리소스에 대한 표현을 반환할 뿐만 아니라 리소스와 상호작용할 수 있는 다른 리소스들의 링크를 함께 제공해야 한다. 즉, 클라이언트는 이 링크들을 통해 다음 상호작용을 선택할 수 있다.
6. Layered System
계층 구조로 설계가 가능해야 하며 각 구성요소는 인접하지 않은 구성요소에 대해 접근할 수 없어야 한다. 복잡성은 제거하고 독립성을 보존할 수 있다.
7. Code-on-Demand
선택적 제약 조건으로, 서버로부터 받은 프로그램이 클라이언트에서 실행되어야 한다는 것을 의미한다.

### 리소스와 Representation
RESTful API에서는 하나의 URI에는 하나의 리소스만 있는 것이 일반적이다. 요청 메서드와 리소스의 식별자를 담은 URI 등을 포함한 요청을 통해 적절한 상태의 Representational Data를 반환하는 것이다. 적절한 상태를 고르는 건 클라이언트와 서버 간의 내용 협상 단계에서 이루어지는데, 사전 협상에서는 클라이언트의 요청을 확인한 서버가 결정해서 적절한 상태의 Representation(rest data, rest metadadata)을 응답한다. 

### 만든 사람이 말하는 RESTful API
로이필딩은 웹을 수정하지 않고 HTTP를 향상시키기 위해 HTTP Object Model, REST를 발표하였다.그 결과, Uniform Interface를 통해 클라이언트 / 서버 독립적인 진화가 가능했다.(상호운용성, Interoperability)

로이필딩은 하이퍼텍스트를 포함한 self-descriptive한 메시지의 uniform을 통해 리소스에 접근할 수 있는 API가 RESTful API라고 할 수 있다고 하였다. 근데 진화에 관심 없거나, 개발자가 서버-클라이언트 모두를 통제할 수 있다고 생각하는거면 RESTful API를 안써도 되니, RESTfulAPI 아닌 API를 가지고 RESTful이라고 말하지 말라고 하였다.

self-descriptvie를 충족하면 서버와 클라이언트가 각자 변경되더라도 오고가는 메시지는 해석이 가능하다. HATEOAS를 충족하면 응답에 포함된 하이퍼미디 메시지를 통해 링크를 동적으로 변경(late binding)할 수 있다. 이 제약조건들을 충족하기 위해서는 다음과 같은 방법이 있다.

#### self-descriptive
media-type을 직접 IANA에 등록하거나, 프로필 페이지를 작성하여 링크해서 해석할 수 있게 됨.
그러나 IANA에 등록하는 건 추가 소요가 발생하고, 프로필 명세만 만들면 클라이언트가 Link헤더와 Proifle을 이해해야하고 content  negotiaition이 안 된다. 
#### HATEOAS
링크 표현법을 직접 정의하고 데이터에 링크값을 직접 넣어두거나 HTTP 헤더에 Link를 써서 충족할 수 있다.

### 우리가 말하는 RESTful API
흔히 실무에서는 Richardson Maturity Model에서 Level 2까지만 달성한 API를 REST API라고 한다. 즉, 리소스를 사용하고, HTTP Method를 통한 요청과 상태코드를 포함한 응답이 이루어져야 한다는 것이다. 여기에 더하여 Collection Pattern을 적용한 URI까지 사용하면 REST API라고 한다.
