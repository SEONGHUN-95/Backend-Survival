# 우아한 객체지향 세미나 (조영호 님)

## 의존성을 통해 설계를 진화시킨다.

## 설계의 핵심은 의존성.

설계란 '코드를 어떻게 배치할 것인가.'에 대한 내용이다.
코드를 설계할 때 변경에 초점을 맞추어야 한다. 코드ㅈ를 설계할 때에는 같이 변경되는 요소들, 즉 의존성을 가지고 있는 관계의 코드를 고려해야 한다.
클래스 의존성의 종류에는 연관관계, 의존관계, 상속관계, 실체화 관계 등이 있으며 의존하는 대상이 바뀌면 의존하고 있는 대상도 바뀔 가능성이 존재한다. 

## 설계시 주의사항

아래의 주의사항을 설계에 도입한다면 객체지향적인 코드를 설계할 수 있음을 
- 양방향 의존성 피하라.
    - 성능 문제, 순환 참조 문제 등이 발생할 수 있다.
    - A가 바뀔 때 B가 바뀌면 또 그 결과로 A가 바뀐다.
- 필요없는 의존성은 제거하라.
    - 의존성이 꼭 필요할 때만 의존성을 부여하라.
- 다수 쪽에 연관관계 주인을 주어라.
    - 다대일 관계에서 '다'쪽에 의존성을 부여해야함.

## 연관관계

클래스의 연관관계는 두 클래스가 밀접한 관계로, 한 클래스가 사용될 때 다른 클래스가 필연적으로 사용되거나 빈도가 높을 때 선정하는 관계이다.
ex) 매장과 주문, 주문과 주문항목

## 의존성 판단하기

설계를 진행하면서 반드시 의존성을 확인하는 것이 필요하다. 
* 코드를 작성하고 점차 조정하는 것도 가능
이러다보면 위에서 말한 주의사항에 위배되는 경우가 발생할 수 있으니 찾아서 수정해야함. 예컨대 비즈니스 로직을 충족시키기 위해 매장이 메뉴를 의존하고 메뉴가 매장을 의존하는 상황. 이럴 때 해결방법 중 하나는 아래와 같다.

- 중간 객체를 생성하여 의존성 사이클 제거한다.
상호 의존성이 발생하여 이를 끊고자 한다면 중간에 추상화된 클래스나 인터페이스를 넣어 이에 의존, 해결할 수 있다.

## 객체 참조의 문제점

예컨대 단방향 참조임에도 객체 참조가 연쇄적인 배달앱이 있다고 하자. 이 앱에서 사용자에게 물건이 배달완료되는 순간, 주문 상태와 가게 상태, 배달 상태 등 많은 것이 업데이트 될 수 있다. 이는 하나의 트랜잭션 범위지만 다른 요소들로 의해서도 각자 변경이 이루어질 수 있어 문제가 된다.
따라서 객체 참조는 반드시 필요한 경우에만 사용하고 그렇지 않으면 최소화하여 결합도를 낮추는 방향으로 가야 한다.

## 어떤 객체를 묶고 어떤 객체는 분리할 것인가?

- 생사를 함께하는 객체는 함께 묶어라
- 도메인 제약사항을 공유하는 객체를 묶어라
- 그럼에도 가능하면 분리하라.
- 한 트랜잭션 안에는 함께 변경되는 요소들끼리만 있어야 한다.
- 각 객체들의 라이프사이클을 생각하자.
- 한 경계 안의 객체는 참조를 이용하여 접근 가능.
- 객체끼리 분리되어 있어서 참조로 조회가 불가능하다면 Id로 조회하면 된다.

즉, 객체를 분리한 단위가 트랜잭션의 단위이자 조회의 단위가 되는 것이다.

응집도란 관련된 책임의 집합이 응집된 정도를 의미한다. 같이 변경되는 애들이 많이 같이 있으면 응집도가 높다고 한다.

## 패키지 의존성 사이클 제거하는 방법 세가지

1. 새로운 중간 객체 생성하여 거기에 의존
2. 인터페이스 만들어 DIP 적용, 의존성 역전
3. 새로운 패키지 생성하여 의존성 제설계

* 단, 사이클을 제거하고 나서도 의존성 관계를 꼭 확인해야함.
