# Layerd Architecture

Layered Architecture은 복잡한 프로그램을 여러 계층으로 나누어 역할과 책임을 분배한 구조이다. 이 구조는 코드의 유연성과 재사용성을 제고하고 용이한 코드 유지보수를 위해 고안되었다. 

## 마틴 파울러의 Presentataion - Domain - Data

마틴 파울러가 제안한 모델은 Presentation - Domain - Data의 세 계층으로 나눈 모델이다. 즉, Presentation 계층에서 HTML 등을 통한 사용자와의 상호작용, Domain 계층에서의 비즈니스 로직처리 및 유효성 검사, Data 계층에서의 영구적인 데이터 관리가 이루어진다는 것이다.

각 계층을 모듈화(계층화)함으로써 개발할 때에는 해당 계층의 역할만을 다루는데 집중할 수 있고, 필요에 따라 구현을 대체(substitute different implementations)할 수 있다. 
구현을 대체함으로써 비즈니스 상의 요구가 수시로 변동이 있을 때에도 유연하게 대처할 수 있다.

또한 계층화는 테스트 가능성을 지원한다. 각자의 역할이 분리된 계층별로 테스트를 하며 개발을 진행함으로써 기능별 문제점을 신속하게 찾아내고 성능을 향상시킬 수 있다.

하지만 프로젝트의 단위가 커지면 커질수록 프레젠테이션 - 도메인 - 데이터를 상위 수준의 모듈로 사용하고, 내부적으로는 계층화된 도메인 모듈의 필요성이 발생한다.

## Layer 4 at Domain Driven Design

에릭에반스는 도메인 주도 설계를 통해 소프트웨어 개발에 있어 4계층 모델을 설명하였다. 이는 인터페이스 계층, 응용 계층, 도메인 계층, 인프라스트럭처 계층이다. 각 계층은 격리되어 독립적인 진화를 할 수 있을 정도로만 연결하여 유연한 애플리케이션 개발이 가능케 한다. 또한 각 계층은 상위 계층이 하위 계층의 인터페이스를 호출하거나 하위 계층에 대한 참조를 가져 느슨하게 결합된다.

인터페이스 계층은 하위 계층들로부터 받은 데이터를 사용자에게 제공하거나, 사용자로부터 받은 입력 정보들을 해석하여 하위계층으로 뿌려주는 일을 한다.

응용 계층은 UI와 도메인 계층의 중간자 역할을 하는 계층이다. UI에서 전달된 요청들을 처리하고 도메인 계층을 보호하며 트랜잭션을 관리하는 등의 기술적 역할도 수행한다.

도메인 계층은 핵심 비즈니스 로직을 구현한 계층이다. 도메인 계층은 애플리케이션의 핵심 계층으로서 다른 계층과의 분리가 철저히 이루어져야 하기 때문에 도메인과 관련된 모든 내용은 해당 계층에서 관리되어야 한다. 이를 통해 도메인의 독립적인 진화가 가능하여 유지보수성이 높은 코드 구현이 가능하다.

인프라 스트럭처 계층은 데이터와 관련된 기술을 제공하는 계층이다. DB, 네트워크, 서버, 보안 등의 역할과 외부 시스템과의 상호작용을 담당한다. 

*** 복잡한 프로그램을 여러 개의 계층으로 나눠라. 응집력 있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전시켜라. 표준 아키텍처 패턴에 따라 상위 계층과의 결합을 느슨하게 유지하라. 도메인 모델과 관련된 코드는 모두 한 계층에 모으고 사용자 인터페이스 코드나 애플리케이션 코드, 인프라스트럭처 코드와 격리하라. 도메인 객체(표현이나 저장, 애플리케이션 작업을 관리하는 등의 책임에서 자유로운)는 도메인 모델을 표현하는 것에만 집중할 수 있다. 이로써 모델은 진화를 거듭해 본질적인 업무 지식을 포착해서 해당 업무 지식이 효과를 발휘할 수 있을 만큼 풍부하고 명확해질 것이다. ***   - 마틴 파울러 

# 관심사의 분리(Separation of Concerns)

관심사의 분리란 소프트웨어의 각 요소들이 서로 다른 관심사와 기능에 집중해야 한다는 것을 의미한다. 이를 통해 각 컴포넌트는 자신에게 주어진 역할만을 온전히 수행하며 다른 컴포넌트들에 대한 의존성은 감소시켜 독립적인 진화가 가능하다. 객체지향에서 핵심적인 원리이다.

예컨대, 웹 개발에 있어서 프론트엔드와 백엔드 계층을 나누어 UI와 비즈니스 로직 처리를 분할하는 것이다. 또, 백엔드 안에서도 비즈니스 로직을 처리하는 것과 DB에 접근하는 것을 나누는 것에서도 관심사의 분리가 나타난다.

관심사의 분리를 할 때 고려해야 할 사항 중 응집도와 결합도가 있다. 응집도는 하나의 목적만을 위해 모듈 안의 요소들, 메서드 클래스 등이 얼마나 밀접하게 관련되어있는지 측정하는 척도이다.
결합도는 한 모듈이 다른 모듈에게 의존하는 정도를 의미한다.  만약 비즈니스 로직을 수정해야하는 상황에서 결합도가 높은 프로젝트는 연쇄적으로 수정할 코드가 많아지게 된다. 응집도와 결합도는 음의 상관관계를 갖는다.

따라서 객체지향적인 코드, 유지보수가 용이하고 재사용성이 높으며 유연한 코드를 위해서는 응집도는 높고 결합도는 낮은 설계를 해야한다.

# Repository

리포지터리는 도메인 모델에게 데이터에 접근할 수 있는 기능을 제공하는 인터페이스다. 즉, 인터페이스를 통한 캡슐화로 객체 지향적인 데이터 접근이 가능해지고 도메인 계층과 데이터 계층 간의 분리를 지원한다. 

스프링에서는 @Repository 애너테이션으로 지정이 가능하고, Data JPA를 통해 이름과 패턴만으로도 별도의 구현 없이 데이터 접근 및 조작이 가능하다.

# DAO

DAO(Data Access Object)는 도메인과 데이터베이스 간의 상호작용을 추상화하여 관심사의 분리를 지원하는 객체이다. 

## Repository VS DAO

둘은 도메인 계층과 데이터 저장소 계층을 분리해주는 기능을 하는데 있어서 비슷하다. 그래서 혼용되어 사용되기도 한다. 하지만 면밀히 말하면 둘의 차이가 존재한다.

차이점을 알아보자. 

Repository는 객체 컬렉션의 추상화이다. 또한, 비즈니스 로직에 더 가까운 상위 레벨에 위치한 인터페이스이다. 

반면 DAO는 데이터 영속성 계층의 추상화이자 데이터 접근 계층으로써의 역할을 수행한다. 테이블 중심의, Repository 보다 더 하위 레벨에 위치한 추상화라고 할 수 있다. 때문에 데이터베이스 테이블과 매핑이 되는 경우가 많다.

* DDD에서는 도메인 전문가 등 기술자가 아닌 팀 멤버들로 인해 리포지터리 패턴이 권유된다.

# VO

VO(Value Object)는 데이터를 담는 데 사용되는 객체이다. VO는 불변성의 특징을 가지며, 이에 따라 필드 값과 생성자 그리고 getter만을 가지고 있다. 때문에 안전한 데이터 전달이 가능하다. 

데이터를 담는 객체라는 측면에서 DTO와 유사하나, VO는 비즈니스 로직에서 주로 사용된다는 점, 불변성을 가진다는 점, 한가지 도메인에 집중적인 속성을 가진다는 점에서 차이가 있다.

# UUID, ULID, TSID

UUID, ULID, TSID는 모두 유일한 ID를 생성하기 위한 방법이다. 다양한 언어에서 사용될 수 있으며 무작위 값이기 때문에 식별자 충돌 가능성이 매우 낮고 타인의 추측이 어렵다.

하지만 UUID는 128비트의 숫자를 가지고 있어 부피가 크고 순서대로 정렬되지 않아 DB의 성능 이슈가 발생할 수 있다.
ULID도 유일한 128비트의 숫자를 가지고 있으며 타임스탬프를 활용하고 시간 순서, 사전적 순서에 따른 정렬이 가능하다. 

TSID는 64비트의 숫자로 구성되어 있으며 42비트는 시간 구성요소, 22비트는 랜덤 구성 요소로 이루어져 있다. TSID도 타임스탬프를 이용하기 때문에 시간 순서대로 정렬이 가능하고 크기가 작아 사용이 편하다. 